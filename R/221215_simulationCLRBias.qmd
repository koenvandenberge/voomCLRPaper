---
title: "Bias in CLR models: simulation"
author: "Koen Van den Berge"
format: 
  html:
    embed-resources: true
    self-contained: true
editor: visual
---

```{r}
#| echo: false
library(ggplot2)
library(voomCLR)
library(limma)
library(genefilter)

theme_set(theme_classic())

```

## Set-up

1.  Simulate absolute cell-count abundances using a log-linear model.

2.  Sample cells from absolute count with probability equal to absolute abundance.

3.  Calculate fold-change on relative counts, and check bias.

## Simulation details

We simulate the equivalence of a log-linear model with two groups.

-   Mean in group1: $\mu_0 \sim NB(\mu=400, \phi=2)$

-   Log-fold-change on absolute counts $\beta \sim lN(\mu_{\beta}=0, \sigma_{\beta}=2)$

-   Decide which log-fold-changes are different from zero $\beta * B(n=1, \pi_{\beta} = .15) * sign$, where sign is randomly selected to be -1 or 1.

-   The log-fold-changes represent $\log(\mu_1/\mu_0) = \beta$. So, $\mu_1 = \exp(\beta) \mu_0$.

-   Calculate true relative abundance for each cell type: $\pi_{p0} = \mu_0 / \sum_p \mu_0$, and similarly for condition 1.

-   Simulate from a Multinomial $Y_{cip} \sim Mult(n= 1e4, \pi=\pi_{p})$, with $\pi_p$ being either $\pi_{p0}$ or $\pi_{p1}$.

# Null simulation

In a null simulation, we don't typically see the bias. But, note that the bias correction is also typically near zero. So doesn't really hurt.

```{r}
logit <- function(x) log(x/(1-x))
set.seed(498735212)
n <- 8 # sample size
P <- 20 # number of cell types
mu0 <- rnbinom(n=P, size=1/2, mu=400)
mu0 # absolute counts in group 0
beta <- rep(0,P) # fold change on log scale
mu1 <- exp(beta) * mu0 # because we want log(mu2/mu1) = beta
log(mu1/(mu0)) # fold-changes OK
df <- data.frame(mu=c(mu0,mu1),
                 celltype=factor(rep(1:P,2)),
                 group=factor(rep(0:1,each=P)))
ggplot(df, aes(x=group, y=log1p(mu), group=celltype, col=celltype)) +
  geom_line()

## relative abundances
relAbundances <- data.frame(g0=mu0/sum(mu0),
                            g1=mu1/sum(mu1)) # relative abundance of absolute count
plot(logit(relAbundances),col=as.numeric(beta==0)+1)
# relative abundance information (observed data in typical experiment)
Y0 <- rmultinom(n=P, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g0)
Y1 <- rmultinom(n=P, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g1)
```

### voomCLR workflow: no bias correction.

```{r}
library(voomCLR)
Y <- cbind(Y0, Y1)
group <- factor(rep(0:1, each=P))
design <- model.matrix(~group)

library(limma)
v <- voomCLR::voomCLR(counts = Y,
             design = design,
             lib.size = NULL)
# v$weights <- matrix(1, nrow=nrow(v$weights), ncol=ncol(v$weights))
fit <- lmFit(v, design)
# fit <- applyBiasCorrection(fit)
fit <- eBayes(fit)

plot(fit$coefficients[,2], #beta=0 so no need to substract
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16)
abline(h=0, col="red", lty=2)
abline(h=mean(fit$coefficients[,2]))
boxplot(fit$coefficients[,2] - beta,
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
```

### Bias correction

```{r}
library(limma)
v <- voomCLR::voomCLR(counts = Y,
             design = design,
             lib.size = NULL)
fit <- lmFit(v, design)
fit <- applyBiasCorrection(fit)
fit <- eBayes(fit)

plot(fit$coefficients[,2], #beta=0 so no need to substract
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16)
abline(h=0, col="red", lty=2)
abline(h=mean(fit$coefficients[,2]))
boxplot(fit$coefficients[,2] - beta,
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)

```

# Heteroscedasticity

## Count-level

```{r}
X <- model.matrix(~0+group)
# mean of group-wise means for each population
yBar <- rowMeans(Y %*% X %*% solve(crossprod(X)))
varY <- rowMeans(cbind(rowVars(Y[,1:P]), rowVars(Y[,(P+1):(2*P)])))

plot(x=yBar, y=varY) ; abline(0,1,col="orange", lwd=2)
plot(x=yBar, y=varY, log="xy") ; abline(0,1,col="orange", lwd=2)



```

## CLR-level

```{r}
clrMat <- v$E
clrBar <- rowMeans(clrMat %*% X %*% solve(crossprod(X)))
varClr <- rowMeans(cbind(rowVars(clrMat[,1:P]), rowVars(clrMat[,(P+1):(2*P)])))

plot(x=clrBar, y=varClr)
estVar <- ((P-1)/P)^2 * (1/yBar)
oo <- order(clrBar)
lines(x=clrBar[oo], y=estVar[oo], col="blue")

```

### Check with voomCLR calculations

```{r}
vLoess <- voomCLR::voomCLR(counts = Y,
             design = design,
             lib.size = NULL,
             varCalc = "empirical")
head(vLoess$weights) # weights are same for all populations and samples!

vDelta <- voomCLR::voomCLR(counts = Y,
             design = design,
             lib.size = NULL,
             varCalc = "analytical")
head(vDelta$weights)

# comparison of weights
plot(vLoess$weights, vDelta$weights) ; abline(0,1,col="orange",lwd=2)
plot(vLoess$weights, vDelta$weights, log="xy") ; abline(0,1,col="orange",lwd=2)
```

# Simulation with DA signal

```{r}
logit <- function(x) log(x/(1-x))
set.seed(495212344)
n <- 40 # sample size
P <- 10 # number of cell types
mu0 <- rnbinom(n=P, size=1/2, mu=400)
mu0[mu0==0] <- rnbinom(n=sum(mu0==0), size=1/2, mu=400) # absolute counts in group 0
beta <- rlnorm(n=P, meanlog = 0, sdlog=2) * # these are log-fold-changes
  rbinom(n=P, size=1, prob=.15) *
  sample(c(-1,1), size=P, replace=TRUE) # fold change on log scale
mu1 <- exp(beta) * mu0 # because we want log(mu2/mu1) = beta
log(mu1/(mu0)) # fold-changes OK
df <- data.frame(mu=c(mu0,mu1),
                 celltype=factor(rep(1:P,2)),
                 group=factor(rep(0:1,each=P)))
ggplot(df, aes(x=group, y=log1p(mu), group=celltype, col=celltype)) +
  geom_line()

## relative abundances
relAbundances <- data.frame(g0=mu0/sum(mu0),
                            g1=mu1/sum(mu1)) # relative abundance of absolute count
plot(logit(relAbundances),col=as.numeric(beta==0)+1)
# relative abundance information (observed data in typical experiment)
Y0 <- rmultinom(n=10, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g0)
Y1 <- rmultinom(n=10, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g1)
```

# Bias evaluation

### voomCLR workflow: no bias correction.

```{r}
Y <- cbind(Y0, Y1)
group <- factor(rep(0:1, each=10))
design <- model.matrix(~group)

v <- voomCLR::voomCLR(counts = Y,
             design = design,
             lib.size = NULL)
# v$weights <- matrix(1, nrow=nrow(v$weights), ncol=ncol(v$weights))
fit <- lmFit(v, design)
# fit <- applyBiasCorrection(fit)
fit <- eBayes(fit)
plot(x=fit$coefficients[,2], y=beta,
     xlab="Estimated log-fold-change",
     ylab="True log-fold-change",
     col=as.numeric(beta==0)+1, pch=16) ; abline(0,1,col="red")
plot(fit$coefficients[,2] - beta, ylim=c(-0.1,0.1),
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
boxplot(fit$coefficients[,2] - beta, ylim=c(-0.1,0.1),
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
```

### Bias correction

```{r}
v <- voomCLR::voomCLR(counts = Y,
             design = design,
             lib.size = NULL)
fit <- lmFit(v, design)
fitBC <- applyBiasCorrection(fit)
fitBC <- eBayes(fitBC)
plot(x=fitBC$coefficients[,2], y=beta,
     xlab="Estimated log-fold-change",
     ylab="True log-fold-change",
     col=as.numeric(beta==0)+1, pch=16) ; abline(0,1,col="red")
plot(fitBC$coefficients[,2] - beta, ylim=c(-0.4,0.4),
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
boxplot(fitBC$coefficients[,2] - beta, ylim=c(-0.4,0.4),
        ylab="Difference (estimated-true LFC)",
        col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)

```

# Heteroscedasticity

## Count-level

```{r}
library(genefilter)
X <- model.matrix(~0+group)
# mean of group-wise means for each population
yBar <- rowMeans(Y %*% X %*% solve(crossprod(X)))
varY <- rowMeans(cbind(rowVars(Y[,1:10]), rowVars(Y[,11:20])))

plot(x=yBar, y=varY)
plot(x=yBar, y=varY, log="xy")



```

## CLR-level

```{r}
clrMat <- v$E
clrBar <- rowMeans(clrMat %*% X %*% solve(crossprod(X)))
varClr <- rowMeans(cbind(rowVars(clrMat[,1:10]), rowVars(clrMat[,11:20])))

plot(x=clrBar[beta==0], y=varClr[beta==0])
estVar <- ((P-1)/P)^2 * (1/yBar)
oo <- order(clrBar)
lines(x=clrBar[oo], y=estVar[oo], col="blue")

```

# Lupus data evaluation of mean-variance

```{r}
lupusCountsWide <- readRDS("../data/lupusPopCountsWide.rds")
### take 48 healthy patients from processing cohort 1
lupusHealthy1 <- lupusCountsWide[lupusCountsWide$Processing_Cohort == "1.0" & lupusCountsWide$Status == "Healthy",]
lupusHealthy1CountMat <- as.matrix(lupusHealthy1[,-c(1:7)])
lupusHealthy1Meta <- lupusHealthy1[,1:8]

### Mean-variance of counts
yBarLupus <- colMeans(lupusHealthy1CountMat)
varYLupus <- rowVars(t(lupusHealthy1CountMat))
m <- lm(varYLupus ~ yBarLupus + I(yBarLupus^2))
gridLupus <- seq(min(yBarLupus), max(yBarLupus), length=50)
yHatLupus <- predict(m, newdata=data.frame(yBarLupus=gridLupus), type="response")
yHatLupusPoints <- predict(m, type="response")
plot(x=yBarLupus, y=varYLupus)
lines(x=gridLupus, y=yHatLupus, col="steelblue")

### Mean-variance of CLR
ict <- rep(1, nrow(lupusHealthy1CountMat))
designLupus <- model.matrix(~ -1 + ict)
vLupus <- voomCLR::voomCLR(counts = t(lupusHealthy1CountMat),
             design = designLupus,
             lib.size = NULL)
clrMatLupus <- vLupus$E
clrBarLupus <- rowMeans(clrMatLupus)
varClrLupus <- rowVars(clrMatLupus)
plot(x=clrBarLupus, y=varClrLupus, ylim=c(0, 3))
estVarLupusPoisson <- ((P-1)/P)^2 * (1/yBarLupus)
oo <- order(clrBarLupus)
lines(x=clrBarLupus[oo], y=estVarLupusPoisson[oo], col="steelblue")
library(glmmTMB)
sigmaVec <- c()
for(kk in 1:nrow(t(lupusHealthy1CountMat))){
  mnb <- suppressWarnings(glmmTMB::glmmTMB(lupusHealthy1CountMat[,kk] ~ 1, 
                          family=nbinom2(link = "log")))
  sigmaVec[kk] <- sigma(mnb)
}
estVarLupusNB <- ((P-1)/P)^2 * (1/yBarLupus + 1/sigmaVec)
lines(x=clrBarLupus[oo], y=estVarLupusNB[oo], col="darkseagreen3")



```

# Composite figure

```{r}
library(ggplot2)

## Bias 
dfBias <- data.frame(betaHat=c(fit$coefficients[,2], fitBC$coefficients[,2]),
                     betaTrue=rep(beta,2),
                     biasCorrected=rep(c(FALSE, TRUE), each=P),
                     signal=rep(beta!=0,2))
pBias <- ggplot(dfBias, aes(x=rep(1:P,2), y=betaHat-betaTrue, col=biasCorrected)) +
  geom_point() +
  geom_hline(yintercept=0, lty=2) +
  geom_hline(yintercept=mean(fit$coefficients[,2]-beta), col="salmon", lty=3) +
  geom_hline(yintercept=mean(fitBC$coefficients[,2]-beta), col="blue", lty=3) +
  xlab("Cell type") +
  ylab("Difference in estimated vs true LFC") +
  scale_x_continuous(breaks=1:P) +
  scale_color_manual(values=c("salmon", "blue"))
pBias

## Mean-variance of simulated counts
dfMVCount <- data.frame(yBar=yBar,
                        varY= varY)
pMVCount <- ggplot(dfMVCount, aes(x=yBar, y=varY)) +
  geom_point() +
  geom_abline(intercept=0, slope=1, lty=2, col="steelblue") +
  xlab("Mean of counts") +
  ylab("Variance of counts")
pMVCount

## Mean-variance of simulated CLR
dfMVCLR <- data.frame(clrBar=clrBar,
                      varClr=varClr)
pMVCLR <- ggplot(dfMVCLR, aes(x=clrBar, y=varClr)) +
  geom_point() +
  geom_line(aes(x=clrBar, y=estVar), lty=2, col="steelblue") +
  xlab("Mean of CLR-transformed counts") +
  ylab("Variance of CLR-transformed counts")
pMVCLR

## Mean-variance of lupus counts
dfMVCountLupus <- data.frame(yBar=yBarLupus,
                        varY= varYLupus)
pMVCountLupus <- ggplot(dfMVCountLupus, aes(x=yBar, y=varY)) +
  geom_point() +
  geom_line(aes(x=yBar, y=yHatLupusPoints), lty=2, col="steelblue") +
  xlab("Mean of counts") +
  ylab("Variance of counts")
pMVCountLupus

## Mean-variance of lupus CLR
dfMVCLRLupus <- data.frame(clrBar=clrBarLupus,
                      varClr=varClrLupus)
pMVCLRLupus <- ggplot(dfMVCLRLupus, aes(x=clrBar, y=varClr)) +
  geom_point() +
  geom_line(aes(x=clrBar, y=estVarLupusNB), lty=2, col="steelblue") +
  xlab("Mean of CLR-transformed counts") +
  ylab("Variance of CLR-transformed counts")
pMVCLRLupus



library(cowplot)
pMVAll <- plot_grid(pMVCount, pMVCLR, pMVCountLupus, pMVCLRLupus,
          labels = letters[2:5])
pAll <- plot_grid(pBias, pMVAll, labels=c(letters[1],NULL), ncol=2, rel_widths = c(0.6,1))
pAll
ggsave("../plots/230524_figure1.pdf", width=11, height=6)
```
