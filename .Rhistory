source("DM_simCP_V2.R")
nn = 10   #sample size
K = P = 12   # number of cell types
var_scale= 1 # scale parameter, higher value for low variability between samples
seed <- 240718
simDataDM <- DM_simCP(sample_size = c(nn, nn),
K = K,
frac.daPop = 0.2,
parent.size = round(runif(n=nn*2, min=1e3, max=2e4)),
scale.dirichlet = var_scale,
sd.intercept=2,
seed = seed)
countsDM <- t(as.matrix(simDataDM$X))
## rm one very lowly abundant cell type with almost all zero
countsDM <- countsDM[-which.min(rowMeans(countsDM)),]
X <- model.matrix(~0+simDataDM$group)
# mean of group-wise means for each population
yBarDM <- rowMeans(countsDM %*% X %*% solve(crossprod(X)))
varYDM <- rowMeans(cbind(rowVars(countsDM[,1:nn]), rowVars(countsDM[,(nn+1):(2*nn)])))
plot(x=yBarDM, y=varYDM)
mDM <- lm(varYDM ~ yBarDM + I(yBarDM^2))
gridDM <- seq(min(yBarDM), max(yBarDM), length=50)
yHatDM <- predict(mDM, newdata=data.frame(yBarDM=gridDM), type="response")
yHatDMPoints <- predict(mDM, type="response")
plot(x=yBarDM, y=varYDM)
lines(x=gridDM, y=yHatDM, col="steelblue")
dfLMDM <- data.frame(grid=gridDM, yHat=yHatDM)
vDM <- voomCLR(counts = countsDM,
design = X)
clrMatDM <- vDM$E
clrBarDM <- rowMeans(clrMatDM %*% X %*% solve(crossprod(X)))
varClrDM <- rowMeans(cbind(rowVars(clrMatDM[,1:nn]), rowVars(clrMatDM[,(nn+1):(2*nn)])))
### Mean-variance of CLR
plot(x=clrBarDM, y=varClrDM)
## Poisson varaince
estVarDMPoisson <- ((P-1)/P)^2 * (1/yBarDM)
oo <- order(clrBarDM)
lines(x=clrBarDM[oo], y=estVarDMPoisson[oo], col="steelblue")
## NB variance: common dispersion
library(edgeR)
d <- DGEList(counts=countsDM)
d <- calcNormFactors(d)
d <- estimateGLMCommonDisp(d, design=X)
d$common.dispersion
estVarDMNBCommon <- ((P-1)/P)^2 * (1/yBarDM + d$common.dispersion)
lines(x=clrBarDM[oo], y=estVarDMNBCommon[oo], col="orange")
## NB variance: cell type specific dispersion
library(glmmTMB)
sigmaVec <- c()
for(kk in 1:nrow(countsDM)){
mnb <- suppressWarnings(glmmTMB::glmmTMB(countsDM[kk,] ~ 1,
family=nbinom2(link = "log")))
sigmaVec[kk] <- sigma(mnb)
}
estVarDMNB <- ((P-1)/P)^2 * (1/yBarDM + 1/sigmaVec)
lines(x=clrBarDM[oo], y=estVarDMNB[oo], col="darkseagreen3")
dfCLRDM <- data.frame(clrBar=clrBarDM[oo],
varClr=varClrDM[oo],
estVarPoisson=estVarDMPoisson[oo],
estVarNBCommon=estVarDMNBCommon[oo],
estVarDMNB=estVarDMNB[oo])
lupusCountsWide <- readRDS("../../data/lupusPopCountsWide.rds")
### take 48 healthy patients from processing cohort 1
lupusHealthy1 <- lupusCountsWide[lupusCountsWide$Processing_Cohort == "1.0" & lupusCountsWide$Status == "Healthy",]
lupusHealthy1CountMat <- as.matrix(lupusHealthy1[,-c(1:7)])
lupusHealthy1Meta <- lupusHealthy1[,1:7]
### Mean-variance of counts
yBarLupus <- colMeans(lupusHealthy1CountMat)
varYLupus <- rowVars(t(lupusHealthy1CountMat))
m <- lm(varYLupus ~ yBarLupus + I(yBarLupus^2))
gridLupus <- seq(min(yBarLupus), max(yBarLupus), length=50)
yHatLupus <- predict(m, newdata=data.frame(yBarLupus=gridLupus), type="response")
yHatLupusPoints <- predict(m, type="response")
plot(x=yBarLupus, y=varYLupus)
lines(x=gridLupus, y=yHatLupus, col="steelblue")
### Mean-variance of CLR
ict <- rep(1, nrow(lupusHealthy1CountMat))
designLupus <- model.matrix(~ -1 + ict)
vLupus <- voomCLR::voomCLR(counts = t(lupusHealthy1CountMat),
design = designLupus,
lib.size = NULL)
clrMatLupus <- vLupus$E
clrBarLupus <- rowMeans(clrMatLupus)
varClrLupus <- rowVars(clrMatLupus)
plot(x=clrBarLupus, y=varClrLupus, ylim=c(0, 1.5))
## Poisson varaince
estVarLupusPoisson <- ((P-1)/P)^2 * (1/yBarLupus)
oo <- order(clrBarLupus)
lines(x=clrBarLupus[oo], y=estVarLupusPoisson[oo], col="steelblue")
## NB variance: common dispersion
library(edgeR)
d <- DGEList(counts=t(lupusHealthy1CountMat))
d <- calcNormFactors(d)
d <- estimateGLMCommonDisp(d, design=designLupus)
d$common.dispersion
estVarLupusNBCommon <- ((P-1)/P)^2 * (1/yBarLupus + d$common.dispersion)
lines(x=clrBarLupus[oo], y=estVarLupusNBCommon[oo], col="orange")
## NB variance: cell type specific dispersion
library(glmmTMB)
sigmaVec <- c()
for(kk in 1:nrow(t(lupusHealthy1CountMat))){
mnb <- suppressWarnings(glmmTMB::glmmTMB(lupusHealthy1CountMat[,kk] ~ 1,
family=nbinom2(link = "log")))
sigmaVec[kk] <- sigma(mnb)
}
#| echo: false
library(ggplot2)
library(voomCLR)
library(limma)
library(genefilter)
theme_set(theme_classic())
logit <- function(x) log(x/(1-x))
set.seed(498735212)
n <- 8 # sample size
P <- 20 # number of cell types
mu0 <- rnbinom(n=P, size=1/2, mu=400)
mu0 # absolute counts in group 0
beta <- rep(0,P) # fold change on log scale
mu1 <- exp(beta) * mu0 # because we want log(mu2/mu1) = beta
log(mu1/(mu0)) # fold-changes OK
df <- data.frame(mu=c(mu0,mu1),
celltype=factor(rep(1:P,2)),
group=factor(rep(0:1,each=P)))
ggplot(df, aes(x=group, y=log1p(mu), group=celltype, col=celltype)) +
geom_line()
## relative abundances
relAbundances <- data.frame(g0=mu0/sum(mu0),
g1=mu1/sum(mu1)) # relative abundance of absolute count
plot(logit(relAbundances),col=as.numeric(beta==0)+1)
# relative abundance information (observed data in typical experiment)
Y0 <- rmultinom(n=P, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g0)
Y1 <- rmultinom(n=P, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g1)
library(voomCLR)
Y <- cbind(Y0, Y1)
group <- factor(rep(0:1, each=P))
design <- model.matrix(~group)
library(limma)
v <- voomCLR::voomCLR(counts = Y,
design = design,
lib.size = NULL)
# v$weights <- matrix(1, nrow=nrow(v$weights), ncol=ncol(v$weights))
fit <- lmFit(v, design)
# fit <- applyBiasCorrection(fit)
fit <- eBayes(fit)
plot(fit$coefficients[,2], #beta=0 so no need to substract
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16)
abline(h=0, col="red", lty=2)
abline(h=mean(fit$coefficients[,2]))
boxplot(fit$coefficients[,2] - beta,
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
library(limma)
v <- voomCLR::voomCLR(counts = Y,
design = design,
lib.size = NULL)
fit <- lmFit(v, design)
fit <- applyBiasCorrection(fit)
fit <- eBayes(fit)
plot(fit$coefficients[,2], #beta=0 so no need to substract
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16)
abline(h=0, col="red", lty=2)
abline(h=mean(fit$coefficients[,2]))
boxplot(fit$coefficients[,2] - beta,
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
X <- model.matrix(~0+group)
# mean of group-wise means for each population
yBar <- rowMeans(Y %*% X %*% solve(crossprod(X)))
varY <- rowMeans(cbind(rowVars(Y[,1:P]), rowVars(Y[,(P+1):(2*P)])))
plot(x=yBar, y=varY) ; abline(0,1,col="orange", lwd=2)
plot(x=yBar, y=varY, log="xy") ; abline(0,1,col="orange", lwd=2)
clrMat <- v$E
clrBar <- rowMeans(clrMat %*% X %*% solve(crossprod(X)))
varClr <- rowMeans(cbind(rowVars(clrMat[,1:P]), rowVars(clrMat[,(P+1):(2*P)])))
plot(x=clrBar, y=varClr)
estVar <- ((P-1)/P)^2 * (1/yBar)
oo <- order(clrBar)
lines(x=clrBar[oo], y=estVar[oo], col="blue")
vLoess <- voomCLR::voomCLR(counts = Y,
design = design,
lib.size = NULL,
varCalc = "empirical")
head(vLoess$weights) # weights are same for all populations and samples!
vDelta <- voomCLR::voomCLR(counts = Y,
design = design,
lib.size = NULL,
varCalc = "analytical")
head(vDelta$weights)
# comparison of weights
plot(vLoess$weights, vDelta$weights) ; abline(0,1,col="orange",lwd=2)
plot(vLoess$weights, vDelta$weights, log="xy") ; abline(0,1,col="orange",lwd=2)
logit <- function(x) log(x/(1-x))
set.seed(495212344)
n <- 40 # sample size
P <- 10 # number of cell types
mu0 <- rnbinom(n=P, size=1/2, mu=400)
mu0[mu0==0] <- rnbinom(n=sum(mu0==0), size=1/2, mu=400) # absolute counts in group 0
beta <- rlnorm(n=P, meanlog = 0, sdlog=2) * # these are log-fold-changes
rbinom(n=P, size=1, prob=.15) *
sample(c(-1,1), size=P, replace=TRUE) # fold change on log scale
mu1 <- exp(beta) * mu0 # because we want log(mu2/mu1) = beta
log(mu1/(mu0)) # fold-changes OK
df <- data.frame(mu=c(mu0,mu1),
celltype=factor(rep(1:P,2)),
group=factor(rep(0:1,each=P)))
ggplot(df, aes(x=group, y=log1p(mu), group=celltype, col=celltype)) +
geom_line()
## relative abundances
relAbundances <- data.frame(g0=mu0/sum(mu0),
g1=mu1/sum(mu1)) # relative abundance of absolute count
plot(logit(relAbundances),col=as.numeric(beta==0)+1)
# relative abundance information (observed data in typical experiment)
Y0 <- rmultinom(n=10, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g0)
Y1 <- rmultinom(n=10, size=runif(n=P, min=1e3, max=2e4), prob=relAbundances$g1)
Y <- cbind(Y0, Y1)
group <- factor(rep(0:1, each=10))
design <- model.matrix(~group)
v <- voomCLR::voomCLR(counts = Y,
design = design,
lib.size = NULL)
# v$weights <- matrix(1, nrow=nrow(v$weights), ncol=ncol(v$weights))
fit <- lmFit(v, design)
# fit <- applyBiasCorrection(fit)
fit <- eBayes(fit)
plot(x=fit$coefficients[,2], y=beta,
xlab="Estimated log-fold-change",
ylab="True log-fold-change",
col=as.numeric(beta==0)+1, pch=16) ; abline(0,1,col="red")
plot(fit$coefficients[,2] - beta, ylim=c(-0.1,0.1),
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
boxplot(fit$coefficients[,2] - beta, ylim=c(-0.1,0.1),
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
v <- voomCLR::voomCLR(counts = Y,
design = design,
lib.size = NULL)
fit <- lmFit(v, design)
fitBC <- applyBiasCorrection(fit)
fitBC <- eBayes(fitBC)
plot(x=fitBC$coefficients[,2], y=beta,
xlab="Estimated log-fold-change",
ylab="True log-fold-change",
col=as.numeric(beta==0)+1, pch=16) ; abline(0,1,col="red")
plot(fitBC$coefficients[,2] - beta, ylim=c(-0.4,0.4),
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
boxplot(fitBC$coefficients[,2] - beta, ylim=c(-0.4,0.4),
ylab="Difference (estimated-true LFC)",
col=as.numeric(beta==0)+1, pch=16); abline(h=0, col="red", lty=2)
library(genefilter)
X <- model.matrix(~0+group)
# mean of group-wise means for each population
yBar <- rowMeans(Y %*% X %*% solve(crossprod(X)))
varY <- rowMeans(cbind(rowVars(Y[,1:10]), rowVars(Y[,11:20])))
plot(x=yBar, y=varY)
plot(x=yBar, y=varY, log="xy")
clrMat <- v$E
clrBar <- rowMeans(clrMat %*% X %*% solve(crossprod(X)))
varClr <- rowMeans(cbind(rowVars(clrMat[,1:10]), rowVars(clrMat[,11:20])))
plot(x=clrBar[beta==0], y=varClr[beta==0])
estVar <- ((P-1)/P)^2 * (1/yBar)
oo <- order(clrBar)
lines(x=clrBar[oo], y=estVar[oo], col="blue")
source("DM_simCP_V2.R")
nn = 10   #sample size
K = P = 12   # number of cell types
var_scale= 1 # scale parameter, higher value for low variability between samples
seed <- 240718
simDataDM <- DM_simCP(sample_size = c(nn, nn),
K = K,
frac.daPop = 0.2,
parent.size = round(runif(n=nn*2, min=1e3, max=2e4)),
scale.dirichlet = var_scale,
sd.intercept=2,
seed = seed)
countsDM <- t(as.matrix(simDataDM$X))
## rm one very lowly abundant cell type with almost all zero
countsDM <- countsDM[-which.min(rowMeans(countsDM)),]
X <- model.matrix(~0+simDataDM$group)
# mean of group-wise means for each population
yBarDM <- rowMeans(countsDM %*% X %*% solve(crossprod(X)))
varYDM <- rowMeans(cbind(rowVars(countsDM[,1:nn]), rowVars(countsDM[,(nn+1):(2*nn)])))
plot(x=yBarDM, y=varYDM)
mDM <- lm(varYDM ~ yBarDM + I(yBarDM^2))
gridDM <- seq(min(yBarDM), max(yBarDM), length=50)
yHatDM <- predict(mDM, newdata=data.frame(yBarDM=gridDM), type="response")
yHatDMPoints <- predict(mDM, type="response")
plot(x=yBarDM, y=varYDM)
lines(x=gridDM, y=yHatDM, col="steelblue")
dfLMDM <- data.frame(grid=gridDM, yHat=yHatDM)
vDM <- voomCLR(counts = countsDM,
design = X)
clrMatDM <- vDM$E
clrBarDM <- rowMeans(clrMatDM %*% X %*% solve(crossprod(X)))
varClrDM <- rowMeans(cbind(rowVars(clrMatDM[,1:nn]), rowVars(clrMatDM[,(nn+1):(2*nn)])))
### Mean-variance of CLR
plot(x=clrBarDM, y=varClrDM)
## Poisson varaince
estVarDMPoisson <- ((P-1)/P)^2 * (1/yBarDM)
oo <- order(clrBarDM)
lines(x=clrBarDM[oo], y=estVarDMPoisson[oo], col="steelblue")
## NB variance: common dispersion
library(edgeR)
d <- DGEList(counts=countsDM)
d <- calcNormFactors(d)
d <- estimateGLMCommonDisp(d, design=X)
d$common.dispersion
estVarDMNBCommon <- ((P-1)/P)^2 * (1/yBarDM + d$common.dispersion)
lines(x=clrBarDM[oo], y=estVarDMNBCommon[oo], col="orange")
## NB variance: cell type specific dispersion
library(glmmTMB)
sigmaVec <- c()
for(kk in 1:nrow(countsDM)){
mnb <- suppressWarnings(glmmTMB::glmmTMB(countsDM[kk,] ~ 1,
family=nbinom2(link = "log")))
sigmaVec[kk] <- sigma(mnb)
}
estVarDMNB <- ((P-1)/P)^2 * (1/yBarDM + 1/sigmaVec)
lines(x=clrBarDM[oo], y=estVarDMNB[oo], col="darkseagreen3")
dfCLRDM <- data.frame(clrBar=clrBarDM[oo],
varClr=varClrDM[oo],
estVarPoisson=estVarDMPoisson[oo],
estVarNBCommon=estVarDMNBCommon[oo],
estVarDMNB=estVarDMNB[oo])
lupusCountsWide <- readRDS("../../data/lupusPopCountsWide.rds")
### take 48 healthy patients from processing cohort 1
lupusHealthy1 <- lupusCountsWide[lupusCountsWide$Processing_Cohort == "1.0" & lupusCountsWide$Status == "Healthy",]
lupusHealthy1CountMat <- as.matrix(lupusHealthy1[,-c(1:7)])
lupusHealthy1Meta <- lupusHealthy1[,1:7]
### Mean-variance of counts
yBarLupus <- colMeans(lupusHealthy1CountMat)
varYLupus <- rowVars(t(lupusHealthy1CountMat))
m <- lm(varYLupus ~ yBarLupus + I(yBarLupus^2))
gridLupus <- seq(min(yBarLupus), max(yBarLupus), length=50)
yHatLupus <- predict(m, newdata=data.frame(yBarLupus=gridLupus), type="response")
yHatLupusPoints <- predict(m, type="response")
plot(x=yBarLupus, y=varYLupus)
lines(x=gridLupus, y=yHatLupus, col="steelblue")
### Mean-variance of CLR
ict <- rep(1, nrow(lupusHealthy1CountMat))
designLupus <- model.matrix(~ -1 + ict)
vLupus <- voomCLR::voomCLR(counts = t(lupusHealthy1CountMat),
design = designLupus,
lib.size = NULL)
clrMatLupus <- vLupus$E
clrBarLupus <- rowMeans(clrMatLupus)
varClrLupus <- rowVars(clrMatLupus)
plot(x=clrBarLupus, y=varClrLupus, ylim=c(0, 1.5))
## Poisson varaince
estVarLupusPoisson <- ((P-1)/P)^2 * (1/yBarLupus)
oo <- order(clrBarLupus)
lines(x=clrBarLupus[oo], y=estVarLupusPoisson[oo], col="steelblue")
## NB variance: common dispersion
library(edgeR)
d <- DGEList(counts=t(lupusHealthy1CountMat))
d <- calcNormFactors(d)
d <- estimateGLMCommonDisp(d, design=designLupus)
d$common.dispersion
estVarLupusNBCommon <- ((P-1)/P)^2 * (1/yBarLupus + d$common.dispersion)
lines(x=clrBarLupus[oo], y=estVarLupusNBCommon[oo], col="orange")
## NB variance: cell type specific dispersion
library(glmmTMB)
sigmaVec <- c()
for(kk in 1:nrow(t(lupusHealthy1CountMat))){
mnb <- suppressWarnings(glmmTMB::glmmTMB(lupusHealthy1CountMat[,kk] ~ 1,
family=nbinom2(link = "log")))
sigmaVec[kk] <- sigma(mnb)
}
estVarLupusNB <- ((P-1)/P)^2 * (1/yBarLupus + 1/sigmaVec)
lines(x=clrBarLupus[oo], y=estVarLupusNB[oo], col="darkseagreen3")
library(ggplot2)
## Mean-variance of simulated Multinomial counts
dfMVCount <- data.frame(yBar=yBar,
varY= varY)
pMVCount <- ggplot(dfMVCount, aes(x=yBar, y=varY)) +
geom_point() +
geom_abline(intercept=0, slope=1, lty=2, col="steelblue", lwd=1) +
xlab("Mean of counts") +
ylab("Variance of counts")
pMVCount
## Mean-variance of simulated Multinomial CLR
dfMVCLR <- data.frame(clrBar=clrBar,
varClr=varClr)
pMVCLR <- ggplot(dfMVCLR, aes(x=clrBar, y=varClr)) +
geom_point() +
geom_line(aes(x=clrBar, y=estVar), lty=2, col="steelblue", lwd=1) +
xlab("Mean of CLR-transformed counts") +
ylab("Variance of CLR-transformed counts")
pMVCLR
## Mean-variance of simulated DM counts
dfDMCount <- data.frame(yBar=yBarDM,
varY= varYDM)
pMVCountDM <- ggplot(dfDMCount, aes(x=yBar, y=varY)) +
geom_point() +
geom_line(data=dfLMDM, aes(x=grid, y=yHat), lty=2, col="steelblue", lwd=1) +
xlab("Mean of counts") +
ylab("Variance of counts")
pMVCountDM
## Mean-variance of simulated DM CLR
pDMCLR <- ggplot(dfCLRDM, aes(x=clrBar, y=varClr)) +
geom_point() +
#geom_line(aes(x=clrBar, y=estVarPoisson), lty=2, col="darkseagreen3") +
#geom_line(aes(x=clrBar, y=estVarNBCommon), lty=2, col="orange") +
geom_line(aes(x=clrBar, y=estVarDMNB), lty=2, col="steelblue", lwd=1) +
xlab("Mean of CLR-transformed counts") +
ylab("Variance of CLR-transformed counts")
pDMCLR
## Mean-variance of lupus counts
dfMVCountLupus <- data.frame(yBar=yBarLupus,
varY= varYLupus)
pMVCountLupus <- ggplot(dfMVCountLupus, aes(x=yBar, y=varY)) +
geom_point() +
geom_line(aes(x=yBar, y=yHatLupusPoints), lty=2, col="steelblue", lwd=1) +
xlab("Mean of counts") +
ylab("Variance of counts")
pMVCountLupus
## Mean-variance of lupus CLR
dfMVCLRLupus <- data.frame(clrBar=clrBarLupus,
varClr=varClrLupus)
pMVCLRLupus <- ggplot(dfMVCLRLupus, aes(x=clrBar, y=varClr)) +
geom_point() +
geom_line(aes(x=clrBar, y=estVarLupusNB), lty=2, col="steelblue", lwd=1) +
xlab("Mean of CLR-transformed counts") +
ylab("Variance of CLR-transformed counts")
pMVCLRLupus
library(cowplot)
pMVAll <- plot_grid(pMVCount, pMVCLR,
pMVCountDM, pDMCLR,
pMVCountLupus, pMVCLRLupus,
labels = letters[c(1,3,5,2,4,6)], ncol=3, byrow=FALSE, align="hv")
pMVAll
ggsave("240828_figure2.pdf", width=11, height=7)
breastCounts <- readRDS("../../data/breastAtlas/240715_cellCountMatrixStromal_mammoplastyWT.rds")
breastMeta <- readRDS("../../data/breastAtlas/240715_cellCountMetaStromal_mammoplastyWT.rds")
### Mean-variance of counts
yBarBreast <- rowMeans(breastCounts)
varYBreast <- rowVars(breastCounts)
m <- lm(varYBreast ~ yBarBreast + I(yBarBreast^2))
gridBreast <- seq(min(yBarBreast), max(yBarBreast), length=50)
yHatBreast <- predict(m, newdata=data.frame(yBarBreast=gridBreast), type="response")
yHatBreastPoints <- predict(m, type="response")
plot(x=yBarBreast, y=varYBreast)
lines(x=gridBreast, y=yHatBreast, col="steelblue")
### Mean-variance of CLR
ict <- rep(1, ncol(breastCounts))
designBreast <- model.matrix(~ -1 + ict)
vBreast <- voomCLR::voomCLR(counts = breastCounts,
design = designBreast,
lib.size = NULL)
clrMatBreast <- vBreast$E
clrBarBreast <- rowMeans(clrMatBreast)
varClrBreast <- rowVars(clrMatBreast)
plot(x=clrBarBreast, y=varClrBreast, ylim=c(0,3))
## Poisson variance
estVarBreastPoisson <- ((P-1)/P)^2 * (1/yBarBreast)
oo <- order(clrBarBreast)
lines(x=clrBarBreast[oo], y=estVarBreastPoisson[oo], col="steelblue")
## NB variance: common dispersion
library(edgeR)
d <- DGEList(counts=breastCounts)
d <- calcNormFactors(d)
d <- estimateGLMCommonDisp(d, design=designBreast)
d$common.dispersion
estVarBreastNBCommon <- ((P-1)/P)^2 * (1/yBarBreast + d$common.dispersion)
lines(x=clrBarBreast[oo], y=estVarBreastNBCommon[oo], col="orange")
## NB variance: cell type specific dispersion
library(glmmTMB)
sigmaVec <- c()
for(kk in 1:nrow(breastCounts)){
mnb <- suppressWarnings(glmmTMB::glmmTMB(breastCounts[,kk] ~ 1,
family=nbinom2(link = "log")))
sigmaVec[kk] <- sigma(mnb)
}
estVarBreastNB <- ((P-1)/P)^2 * (1/yBarBreast + 1/sigmaVec)
lines(x=clrBarBreast[oo], y=estVarBreastNB[oo], col="darkseagreen3")
library(tidyverse)
library(limma)
library(voomCLR)
lupusCountsWide <- readRDS("../data/230705_popCountsWide_individualBatchID.rds")
table(lupusCountsWide$pop_cov) # paper looks at Asians and Europeans separately.
table(lupusCountsWide$pop_cov, lupusCountsWide$ind_cov) # paper looks at Asians and Europeans separately.
rowSums(table(lupusCountsWide$pop_cov, lupusCountsWide$ind_cov)>0)
sum(rowSums(table(lupusCountsWide$pop_cov, lupusCountsWide$ind_cov)>0))
table(lupusCountsWide$pop_cov) # paper looks at Asians and Europeans separately.
sum(table(lupusCountsWide$pop_cov))
rowSums(table(lupusCountsWide$group, lupusCountsWide$ind_cov)>0)
156+19
175+99
table(lupusCountsWide$pop_cov, useNA = "ifany")
table(lupusCountsWide$ind_cov, useNA = "ifany")
table(lupusCountsWide$group, useNA = "ifany")
rowSums(table(lupusCountsWide$group, lupusCountsWide$ind_cov)>0)
sum(rowSums(table(lupusCountsWide$group, lupusCountsWide$ind_cov)>0))
nlevels(lupusCountsWide$ind_cov)
lupusCountsWide$group
lupusCountsWide$ind_cov
nlevels(droplevels(lupusCountsWide$ind_cov))
sum(rowSums(table(lupusCountsWide$group, lupusCountsWide$ind_cov)>0))
table(lupusCountsWide$group, lupusCountsWide$ind_cov)
sum(rowSums(table(lupusCountsWide$group, lupusCountsWide$ind_cov)))
sum(rowSums(table(lupusCountsWide$group, lupusCountsWide$ind_cov)>0))
nlevels(lupusCountsWide$ind_cov)
table(lupusCountsWide$SLE_status)
sum(rowSums(table(lupusCountsWide$SLE_status, lupusCountsWide$ind_cov)>0))
rowSums(table(lupusCountsWide$SLE_status, lupusCountsWide$ind_cov)>0)
lupusCountsWide <- readRDS("../data/230705_popCountsWide_individualBatchID.rds")
table(lupusCountsWide$pop_cov) # paper looks at Asians and Europeans separately.
lupusCountsWide <- lupusCountsWide[!lupusCountsWide$pop_cov %in% c("African American", "Hispanic"),]
nlevels(droplevels(lupusCountsWide$ind_cov))
